{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"baseHeaderView\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1);\n}","map":{"version":3,"mappings":";;EACOA,KAAK,EAAC;AAAgB;;uBAA3BC,oBAGM,OAHNC,UAGM","names":["class","_createElementBlock","_hoisted_1"],"sourceRoot":"","sources":["C:\\Users\\Osstem\\Desktop\\vue-canvas-gui-programming\\canvasjs\\src\\components\\BaseHaederView.vue"],"sourcesContent":["<template>\r\n  <div class=\"baseHeaderView\">\r\n    \r\n    \r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport '@/assets/css/utility.css';\r\nimport {xmlToJson} from '@/assets/js/x2j.js';\r\n\r\nimport axios from \"axios\";\r\nimport drf from '@/api/drf';\r\nimport {mapGetters, mapActions} from 'vuex';\r\nimport Constant from \"@/common/Constant.js\";\r\n\r\nexport default {\r\n  name: 'BaseUtilityView',\r\n\r\n  components: {},\r\n\r\n  data: () => ({\r\n    /***\r\n     * patient info\r\n     * */\r\n    patientInfo: {},\r\n\r\n    /***\r\n     * width, height\r\n     * */\r\n    DPI: 96,\r\n    // canvas width, height\r\n    canvasWidth: 0,\r\n    canvasHeight: 0,\r\n\r\n    // pixel * pixel spacing / 25.4 * 96\r\n    realityImageWidth: 0,\r\n    realityImageHeight: 0,\r\n    //=========================================\r\n\r\n    /***\r\n     * canvas\r\n     * */\r\n    imageArr: [],\r\n    downFlag: false,\r\n    x: 0,\r\n    y: 0,\r\n    strokeType: \"freedraw\",\r\n    fillShape: false,\r\n    backgroundImage: null,\r\n\r\n    /***\r\n     * panning\r\n     * */\r\n    startTop: 0,\r\n    startLeft: 0,\r\n    movingTop: 0,\r\n    movingLeft: 0,\r\n\r\n    /***\r\n     * required drawing\r\n     * */\r\n    canvas: null,\r\n    context: null,\r\n    divCanvas: null,\r\n    divContext: null,\r\n\r\n    strokes: {\r\n      type: '',\r\n      from: {\r\n        x: 0,\r\n        y: 0\r\n      },\r\n      coordinates: [],\r\n      color: '',\r\n      width: '',\r\n      fill: false,\r\n      lineCap: '',\r\n      lineJoin: ''\r\n    },\r\n    lineCount: 0,\r\n    drawMarkArray: [],\r\n    guides: [],\r\n    trash: [],\r\n\r\n    mainImg: require('@/assets/img/board.png'),\r\n    tempImage: '',\r\n    guideTempImage: '',\r\n    overlaies: [],\r\n    reSizeScale: 0,\r\n    scale: 0.0,\r\n    angle: 0,\r\n    symmetry: 1,\r\n    verticalSymmetry: 1,\r\n    //=========================================\r\n\r\n    /***\r\n     * stroke\r\n     * */\r\n    lineColor: '#ff0000',\r\n    lineWidth: 2,\r\n    //=========================================\r\n\r\n    /***\r\n     * icon list\r\n     * */\r\n    disable: false,\r\n    lock: '',\r\n    first: {\r\n      pan: false,\r\n      zoom: false,\r\n    },\r\n    second: {\r\n      bright: false,\r\n      inverse: false,\r\n      sharpen: false,\r\n      ruler: false,\r\n      tapeline: false,\r\n      draw: false\r\n    },\r\n    third: ['01', '02', '03', '04'],\r\n    //=========================================\r\n  }),\r\n\r\n  mounted() {\r\n    window.addEventListener('resize', this.handleResize);\r\n    this.canvas = document.getElementById('canvas');\r\n    this.context = this.canvas.getContext('2d');\r\n\r\n    this.context.save();\r\n    this.divCanvas = document.getElementById('divCanvas');\r\n    this.canvasHeight = this.divCanvas.clientHeight - 2;\r\n    this.canvasWidth = this.divCanvas.clientWidth - 2;\r\n  },\r\n\r\n  computed: {\r\n    ...mapGetters([\r\n      'patientRecordList',\r\n      'patientSeriesList',\r\n    ]),\r\n  },\r\n\r\n  watch: {\r\n    patientSeriesList: {\r\n      deep: true,\r\n      async handler() {\r\n        this.imageArr = [];\r\n\r\n        const chartId = this.patientSeriesList.chartId;\r\n        for (let e of this.patientSeriesList.entity) {\r\n          const createdTime = e.Created;\r\n          const url = await axios({\r\n            url: drf.patient.patientImgFileDownload(e.UniqueID),\r\n            method: 'get',\r\n            responseType: 'blob',\r\n          })\r\n          const blobImage = URL.createObjectURL(new Blob([url.data], {type: 'image/bmp'}));\r\n          window.onload = function () {\r\n            this.context.drawImage(blobImage, 0, 0, 1000, 1000);\r\n          }\r\n          const markCoordinate = await axios({\r\n            url: drf.patient.drawImage(e.UniqueID),\r\n            method: 'get',\r\n            headers: {\r\n              \"Content-Type\": \"multipart/form-data\"\r\n            }\r\n          })\r\n\r\n          // xml to json\r\n          let XmlNode = new DOMParser().parseFromString(e.Tags, \"text/xml\");\r\n          const json = xmlToJson(XmlNode);\r\n          this.realityImageWidth = (json.tags.tags[0].tag[0][\"@attributes\"].value * e.PixelSpacingV) / 25.4 * this.DPI;\r\n          this.realityImageHeight = (json.tags.tags[0].tag[1][\"@attributes\"].value * e.PixelSpacingH) / 25.4 * this.DPI;\r\n\r\n          // 이미지 마다 다른 것\r\n          this.imageArr.push({\r\n            // 차트ID\r\n            chartId: chartId,\r\n            // 마커 정보\r\n            images: blobImage,\r\n            // 마커 파일\r\n            drawMark: markCoordinate,\r\n            // 생성 일자\r\n            create: createdTime,\r\n            // 너비\r\n            ph: this.realityImageWidth,\r\n            // 높이\r\n            pw: this.realityImageHeight,\r\n            // 마커 배열\r\n            overlaies: markCoordinate.data === '' ? [] : markCoordinate.data.overlaies,\r\n          })\r\n          this.disable = true;\r\n\r\n          await axios({\r\n            url: drf.patient.getPatientInfo('4629CF54C49549F59AFBB99D9FC82D8F'),\r\n            method: 'get',\r\n          }).then(res => {\r\n            this.patientInfo = res.data.Result;\r\n          })\r\n\r\n          this.overlaies = markCoordinate.data === '' ? [] : markCoordinate.data.overlaies;\r\n          this.mainImg = blobImage;\r\n        }\r\n\r\n        await this.setCanvasTransrateAndScale();\r\n        setTimeout(() => this.importOne2Drawing(), 10);\r\n      }\r\n    }\r\n  },\r\n\r\n  methods: {\r\n    async handleResize() {\r\n      this.canvasHeight = this.divCanvas.clientHeight - 2;\r\n      this.canvasWidth = this.divCanvas.clientWidth - 2;\r\n      this.movingTop = 0;\r\n      this.movingLeft = 0;\r\n      await this.setCanvasTransrateAndScale();\r\n      setTimeout(() => this.markDraw(), 1);\r\n    },\r\n\r\n    /***\r\n     * ===============================================================\r\n     * panning & scale\r\n     * ===============================================================\r\n     * */\r\n    startMoving(e) {\r\n      if (this.first.pan && !this.mouseFlag) {\r\n        this.startTop = e.screenY;\r\n        this.startLeft = e.screenX;\r\n        this.mouseFlag = true;\r\n      }\r\n    },\r\n    async moveImage(e) {\r\n      if (this.first.pan && this.mouseFlag) {\r\n        this.movingTop += e.screenY - this.startTop;\r\n        this.startTop = e.screenY;\r\n        this.movingLeft += e.screenX - this.startLeft;\r\n        this.startLeft = e.screenX;\r\n\r\n        await this.setCanvasTransrateAndScale();\r\n        setTimeout(() => this.markDraw(), 1);\r\n      }\r\n    },\r\n    endMoving() {\r\n      if (this.first.pan && this.mouseFlag) {\r\n        this.mouseFlag = false;\r\n      }\r\n    },\r\n    async changedScale(e) {\r\n      if (this.first.zoom) {\r\n        const rate = 0.005;\r\n        if (e.deltaY > 0) this.scale -= rate;\r\n        else if (e.deltaY < 0) this.scale += rate;\r\n        await this.setCanvasTransrateAndScale();\r\n        setTimeout(() => this.markDraw(), 1);\r\n      }\r\n    },\r\n\r\n    /***\r\n     * ===============================================================\r\n     * brightness, inverse, sharpen\r\n     * ===============================================================\r\n     * */\r\n\r\n    /***\r\n     * ===============================================================\r\n     * Set transrate scale\r\n     * ===============================================================\r\n     * */\r\n    async setCanvasTransrateAndScale() {\r\n      this.context.restore();\r\n      this.context.save();\r\n      // 1. Rect 클리어\r\n      this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n\r\n      // 2. 가로/세로 중 reSize 크기 선택\r\n      if (this.angle === 0 || this.angle === 180) {\r\n        [this.reSizeScale] = await Promise.all([Math.min(this.canvasWidth / this.realityImageWidth, this.canvasHeight / this.realityImageHeight)]);\r\n      } else if (this.angle === 90 || this.angle === 270) {\r\n        [this.reSizeScale] = await Promise.all([Math.min(this.canvasWidth / this.realityImageHeight, this.canvasHeight / this.realityImageWidth)]);\r\n      }\r\n      this.reSizeScale += this.scale;\r\n\r\n      // 3. 스케일 -> 캔바스 스케일을 높이와 너비 중 짧은 걸 기준으로 맞춤\r\n      this.context.scale(this.reSizeScale, this.reSizeScale);\r\n\r\n      // 4. 트랜스레이트 -> 화면의 중앙으로 이동\r\n      this.context.translate(this.canvasWidth / this.reSizeScale / 2.0 + this.movingLeft, this.canvasHeight / this.reSizeScale / 2.0 + this.movingTop);\r\n      // 5. 로테이트 -> 효과 적용\r\n      this.context.rotate((Math.PI / 180) * this.angle);\r\n      // 6. 트랜스레이트 -> 화면의 중앙에서 그림 박기 위한 0, 0으로 이동\r\n      this.context.translate(this.realityImageWidth / -2.0, this.realityImageHeight / -2.0);\r\n\r\n      // 7. 상하좌우반전 유무\r\n      if (this.angle === 0 || this.angle === 180) {\r\n        if (this.symmetry === -1) {\r\n          this.context.translate(this.realityImageWidth, 0);\r\n        }\r\n        if (this.verticalSymmetry === -1) {\r\n          this.context.translate(0, this.realityImageHeight);\r\n        }\r\n        this.context.scale(this.symmetry, this.verticalSymmetry);\r\n      } else if (this.angle === 90 || this.angle === 270) {\r\n        if (this.symmetry === -1) {\r\n          this.context.translate(0, this.realityImageHeight);\r\n        }\r\n        if (this.verticalSymmetry === -1) {\r\n          this.context.translate(this.realityImageWidth, 0);\r\n        }\r\n        this.context.scale(this.verticalSymmetry, this.symmetry);\r\n      }\r\n\r\n      // 8. 이미지 그리기\r\n      if (this.tempImage) {\r\n        this.context.drawImage(this.tempImage, 0, 0, this.realityImageWidth, this.realityImageHeight);\r\n        if (this.second['inverse'] === true) {\r\n          const imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n          // 픽셀 데이터를 반전시킵니다.\r\n          const data = imageData.data;\r\n          console.log(data);\r\n          for (let i = 0; i < data.length; i += 4) {\r\n            data[i] = 255 - data[i]; // 빨간색\r\n            data[i + 1] = 255 - data[i + 1]; // 초록색\r\n            data[i + 2] = 255 - data[i + 2]; // 파란색\r\n          }\r\n\r\n          // 변경된 이미지 데이터를 다시 캔버스에 그립니다.\r\n          this.context.putImageData(imageData, 0, 0);\r\n          // 변경된 이미지를 이미지 요소에 설정합니다.\r\n          // image.src = canvas.toDataURL();\r\n        }\r\n        // 9. 마커 그리기 위해 다시 원점 중앙 이동\r\n        this.context.translate(this.realityImageWidth / 2.0, this.realityImageHeight / 2.0);\r\n        console.log('111111111111');\r\n      } else {\r\n        const image = new Image();\r\n        image.src = this.mainImg;\r\n        this.tempImage = image;\r\n        image.onload = async () => {\r\n          this.context.drawImage(image, 0, 0, this.realityImageWidth, this.realityImageHeight);\r\n          // 9. 마커 그리기 위해 다시 원점 중앙 이동\r\n          this.context.translate(this.realityImageWidth / 2.0, this.realityImageHeight / 2.0);\r\n          console.log('2222222222222');\r\n        }\r\n      }\r\n    },\r\n\r\n    /***\r\n     * ===============================================================\r\n     * freedraw\r\n     * ===============================================================\r\n     * */\r\n    startDraw(event) {\r\n      if (!this.lock) {\r\n        this.drawing = true;\r\n        let coordinate = this.getCoordinates(event);\r\n        if (this.strokeType === 'freedraw' || this.lineCount === 0) {\r\n          this.strokes = {\r\n            type: this.eraser ? 'eraser' : this.strokeType,\r\n            from: coordinate,\r\n            coordinates: [],\r\n            color: this.lineColor,\r\n            width: this.lineWidth,\r\n            fill: this.eraser ||\r\n            this.strokeType === 'freedraw' ||\r\n            this.strokeType === 'ruler' ||\r\n            this.strokeType === 'tapeline'\r\n                ? false : this.fillShape,\r\n            lineCap: this.lineCap,\r\n            lineJoin: this.lineJoin\r\n          };\r\n        }\r\n\r\n        if (this.strokeType === 'ruler') {\r\n          const image = new Image();\r\n          image.src = this.canvas.toDataURL('image/png');\r\n          this.guideTempImage = image;\r\n        }\r\n      }\r\n    },\r\n\r\n    lineDraw(event) {\r\n      let coordinate = this.getCoordinates(event);\r\n      if (this.drawing) {\r\n        if (this.strokeType === 'freedraw') {\r\n          this.strokes.coordinates.push(coordinate);\r\n          this.drawShape(this.strokes);\r\n        }\r\n      }\r\n      if (this.lineCount > 0) {\r\n        switch (this.strokeType) {\r\n          case 'ruler':\r\n            this.guides = [{\r\n              x: coordinate.x,\r\n              y: coordinate.y\r\n            }];\r\n            break;\r\n        }\r\n\r\n        this.drawGuide();\r\n      }\r\n    },\r\n\r\n    async markDraw() {\r\n      for (let m of this.drawMarkArray) {\r\n        this.drawShape(m);\r\n      }\r\n    },\r\n    async drawCircle() {\r\n      this.context.beginPath();\r\n      this.context.arc(0, 0, 20, 0, 2 * Math.PI);\r\n      this.context.stroke();\r\n    },\r\n\r\n    async drawGuide() {\r\n      this.context.clearRect(this.canvasWidth / this.reSizeScale / -2,\r\n          this.canvasHeight / this.reSizeScale / -2,\r\n          this.canvasWidth / this.reSizeScale,\r\n          this.canvasHeight / this.reSizeScale);\r\n      this.context.drawImage(this.guideTempImage,\r\n          this.canvasWidth / this.reSizeScale / -2,\r\n          this.canvasHeight / this.reSizeScale / -2,\r\n          this.canvasWidth / this.reSizeScale,\r\n          this.canvasHeight / this.reSizeScale);\r\n      /*await this.setCanvasTransrateAndScale();\r\n      setTimeout(() => this.markDraw(), 20);*/\r\n\r\n      this.context.strokeStyle = this.lineColor;\r\n      this.context.lineWidth = this.lineWidth;\r\n      this.context.lineJoin = this.lineJoin;\r\n      this.context.lineCap = this.lineCap;\r\n      this.context.beginPath();\r\n      this.context.moveTo(this.strokes.from.x, this.strokes.from.y);\r\n      this.guides.forEach(coordinate => {\r\n        this.context.lineTo(coordinate.x, coordinate.y);\r\n      });\r\n\r\n      // 단위 표시\r\n      if (this.strokes.type === 'ruler') {\r\n        this.context.fillStyle = \"#ffff00\";\r\n        let distance = this.getDistance([{x: this.strokes.from.x, y: this.strokes.from.y},\r\n          {x: this.guides[0].x, y: this.guides[0].y}]);\r\n        this.context.font = \"10px serif\"\r\n        this.context.textAlign = \"center\"\r\n        this.context.textBaseline = \"alphabetic\";\r\n        this.context.fillStyle = \"#ffff00\";\r\n\r\n        /*const x1 = Math.abs(this.strokes.from.x),\r\n            x2 = Math.abs(this.guides[0].x),\r\n            y1 = Math.abs(this.strokes.from.y),\r\n            y2 = Math.abs(this.guides[0].y);*/\r\n\r\n        const dx = (this.canvasWidth / this.reSizeScale / 2.0);\r\n        const dy = (this.canvasHeight / this.reSizeScale / 2.0);\r\n\r\n        const x1 = dx + this.strokes.from.x,\r\n            x2 = dx + this.guides[0].x,\r\n            y1 = dy + this.strokes.from.y,\r\n            y2 = dy + this.guides[0].y;\r\n\r\n        const diffX = Math.abs(x1 - x2) - dx;\r\n        const diffY = Math.abs(y1 - y2) - dy;\r\n        // console.log(diffX / 2 / 25.4 * this.DPI);\r\n        // console.log(diffY / 2 / 25.4 * this.DPI);\r\n        // console.log(x1, x2, y1, y2);\r\n        this.context.fillText(distance,\r\n            diffX / 2 / 25.4 * this.DPI,\r\n            diffY / 2 / 25.4 * this.DPI);\r\n\r\n        /*console.log((this.strokes.from.x - this.guides[0].x) / 2 / 25.4 * this.DPI);\r\n        console.log((this.strokes.from.y - this.guides[0].y) / 2 / 25.4 * this.DPI);*/\r\n      }\r\n\r\n      this.context.closePath();\r\n      this.context.stroke();\r\n\r\n    },\r\n\r\n    drawShape(stroke) {\r\n      this.context.strokeStyle = stroke.color;\r\n      this.context.fillStyle = stroke.color;\r\n      this.context.lineWidth = stroke.width;\r\n      this.context.lineJoin = \"round\";\r\n      this.context.lineCap = \"round\";\r\n      this.context.beginPath();\r\n      this.context.setLineDash([]);\r\n\r\n      this.context.moveTo(stroke.from.x, stroke.from.y);\r\n      stroke.coordinates.forEach(s => {\r\n        this.context.lineTo(s.x, s.y);\r\n      });\r\n\r\n      // 단위 표시\r\n      if (stroke.coordinates.valueBox) {\r\n        this.context.fillStyle = \"#ffff00\";\r\n        let distance\r\n        if (stroke.type === 'length') {\r\n          distance = this.getDistance([{x: stroke.from.x, y: stroke.from.y},\r\n            {x: stroke.coordinates[0].x, y: stroke.coordinates[0].y}]);\r\n        } else if (stroke.type === 'tapeline') {\r\n          distance = this.getDistance(stroke.coordinates);\r\n        }\r\n        this.context.font = \"10px serif\"\r\n        this.context.textAlign = \"center\"\r\n        this.context.textBaseline = \"alphabetic\";\r\n        this.context.fillStyle = \"#ffff00\";\r\n        this.context.fillText(distance, stroke.coordinates.valueBox.x / 25.4 * this.DPI, stroke.coordinates.valueBox.y / 25.4 * this.DPI);\r\n      }\r\n      this.context.stroke();\r\n    },\r\n\r\n    stopDraw() {\r\n      if (this.drawing) {\r\n        this.strokes.coordinates = this.guides.length > 0 ? this.guides : this.strokes.coordinates;\r\n        if (this.strokeType === 'ruler') {\r\n          this.lineCount++;\r\n        }\r\n\r\n        if (this.strokeType === 'freedraw' ||\r\n            (this.strokeType === 'ruler' && this.lineCount === 2)) {\r\n          this.drawMarkArray.push(this.strokes);\r\n          this.lineCount = 0;\r\n        }\r\n\r\n        this.drawing = false;\r\n        this.trash = [];\r\n      }\r\n    },\r\n\r\n    getCoordinates(event) {\r\n      this.x = (event.offsetX - (this.canvasWidth / 2.0)) / this.reSizeScale;\r\n      this.y = (event.offsetY - (this.canvasHeight / 2.0)) / this.reSizeScale;\r\n\r\n      // 오일러 함수를 이용한 좌표 회전\r\n      this.y *= -1;\r\n      for (let i = 0, cnt = this.angle / 90; i < cnt; i++) {\r\n        [this.x, this.y] = [-this.y, this.x];\r\n      }\r\n      this.y *= -1;\r\n\r\n      // panning 기능을 위한 좌표 이동\r\n      if (this.angle === 0) {\r\n        this.x += -this.movingLeft;\r\n        this.y += -this.movingTop;\r\n      } else if (this.angle === 90) {\r\n        this.x += -this.movingTop;\r\n        this.y += this.movingLeft;\r\n      } else if (this.angle === 180) {\r\n        this.x += this.movingLeft;\r\n        this.y += this.movingTop;\r\n      } else {\r\n        this.x += this.movingTop;\r\n        this.y += -this.movingLeft;\r\n      }\r\n\r\n      if (this.angle === 0 || this.angle === 180) {\r\n        if (this.symmetry === -1) this.x *= -1;\r\n        if (this.verticalSymmetry === -1) this.y *= -1;\r\n      } else if (this.angle === 90 || this.angle === 270) {\r\n        if (this.symmetry === -1) this.y *= -1;\r\n        if (this.verticalSymmetry === -1) this.x *= -1;\r\n      }\r\n\r\n      return {\r\n        x: this.x,\r\n        y: this.y\r\n      };\r\n    },\r\n\r\n    // 4-1, 4-2\r\n    async reset() {\r\n      if (!this.lock) {\r\n        this.first.pan = false;\r\n        this.first.zoom = false;\r\n\r\n        this.second.bright = false;\r\n        this.second.inverse = false;\r\n        this.second.sharpen = false;\r\n\r\n        this.second.ruler = false;\r\n        this.second.tapeline = false;\r\n        this.second.draw = false;\r\n\r\n        this.scale = 1.0;\r\n        this.brightness = 100;\r\n        this.inverse = 0;\r\n\r\n        this.strokes = {\r\n          type: '',\r\n          coordinates: [],\r\n          color: '',\r\n          width: '',\r\n          fill: false,\r\n          lineCap: '',\r\n          lineJoin: ''\r\n        };\r\n\r\n        this.tempImage = '';\r\n        // this.mainImg = require('@/assets/img/board.png');\r\n        this.drawMarkArray = [];\r\n        this.guides = [];\r\n        this.trash = [];\r\n        await this.setCanvasTransrateAndScale();\r\n      }\r\n    },\r\n\r\n    async undo() {\r\n      if (!this.lock) {\r\n        let strokes = this.drawMarkArray.pop();\r\n\r\n        if (strokes) {\r\n          this.trash.push(strokes);\r\n          await this.setCanvasTransrateAndScale();\r\n          setTimeout(() => this.markDraw(), 5);\r\n        }\r\n      }\r\n    },\r\n\r\n    async redo() {\r\n      if (!this.lock) {\r\n        let strokes = this.trash.pop();\r\n\r\n        if (strokes) {\r\n          this.drawMarkArray.push(strokes);\r\n          await this.setCanvasTransrateAndScale();\r\n          setTimeout(() => this.markDraw(), 5);\r\n        }\r\n      }\r\n    },\r\n\r\n    /***\r\n     * ===============================================================\r\n     * Event\r\n     * ===============================================================\r\n     * */\r\n    checkedButtonToggling(idx, name, bool) {\r\n      if (this.disable) {\r\n        if (idx[name] === bool) {\r\n          this.first.pan = false;\r\n          this.second.bright = false;\r\n          this.second.ruler = false;\r\n          this.second.tapeline = false;\r\n          this.second.draw = false;\r\n          idx[name] = !bool;\r\n        }\r\n      }\r\n    },\r\n\r\n    // 2-1, 2-3\r\n    changedMouseWheelEvent(e) {\r\n      if (this.downFlag && this.second.bright) {\r\n        this.lock = this.second.bright;\r\n        this.preX = this.x;\r\n        this.preY = this.y;\r\n        this.getCoordinates(e);\r\n        if (this.preX < this.x || this.preY < this.y) {\r\n          this.brightness += 2;\r\n        } else if (this.preX > this.x || this.preY > this.y) {\r\n          this.brightness -= 2;\r\n        }\r\n      }\r\n    },\r\n\r\n    // 2-2, 4-1, 4-2, 4-3, 4-3\r\n    async changedEvent(e) {\r\n      if (this.disable) {\r\n        if (e === 'inverse') {\r\n          console.log(this.second['inverse']);\r\n          /*// Change Inverse\r\n          // 2-2\r\n          if (this.second[e] === true) {\r\n            const imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n            console.log(imageData);\r\n            // 픽셀 데이터를 반전시킵니다.\r\n            const data = imageData.data;\r\n            for (let i = 0; i < data.length; i += 4) {\r\n              data[i] = 255 - data[i]; // 빨간색\r\n              data[i+1] = 255 - data[i+1]; // 초록색\r\n              data[i+2] = 255 - data[i+2]; // 파란색\r\n            }\r\n\r\n            // 변경된 이미지 데이터를 다시 캔버스에 그립니다.\r\n            // this.context.putImageData(imageData, 0, 0);\r\n            // 변경된 이미지를 이미지 요소에 설정합니다.\r\n            // image.src = canvas.toDataURL();\r\n          }*/\r\n          await this.setCanvasTransrateAndScale();\r\n          setTimeout(() => this.markDraw(), 10);\r\n        } else if (typeof e === 'number') {\r\n          // Change Angle\r\n          // 3-1, 2, 3, 4\r\n          if (e === 0) {\r\n            this.angle += 90;\r\n            if (this.angle === 360) this.angle = 0;\r\n          } else if (e === 1) {\r\n            if (this.angle === 0) this.angle = 360;\r\n            this.angle -= 90;\r\n          } else if (e === 2) {\r\n            this.symmetry *= -1;\r\n          } else if (e === 3) {\r\n            this.verticalSymmetry *= -1;\r\n          }\r\n\r\n          await this.setCanvasTransrateAndScale();\r\n          setTimeout(() => this.markDraw(), 10);\r\n        }\r\n      }\r\n    },\r\n\r\n    // 2-4, 2-8, 2-9, 3-1\r\n    changedStrokeType(s) {\r\n      if (this.disable) {\r\n        if (s === 'pan') {\r\n          this.lock = true;\r\n        } else if (s === 'zoom') {\r\n          this.lock = true;\r\n        } else if (s === 'ruler') {\r\n          this.strokeType = 'ruler';\r\n          this.lock = !this.second.ruler;\r\n        } else if (s === 'tapeline') {\r\n          this.strokeType = 'tapeline';\r\n          this.lock = !this.second.tapeline;\r\n        } else if (s === 'draw') {\r\n          this.strokeType = 'freedraw';\r\n          this.lock = !this.second.draw;\r\n        }\r\n      }\r\n      /*else {\r\n        this.lock = true;\r\n      }*/\r\n    },\r\n\r\n    getDistance(arr) {\r\n      let distance = 0;\r\n      let x = arr[0].x;\r\n      let y = arr[0].y;\r\n      arr.forEach(a => {\r\n        distance += Math.pow(Math.pow(y - a.y, 2) + Math.pow(x - a.x, 2), 0.5);\r\n        x = a.x;\r\n        y = a.y;\r\n      });\r\n      // Number.EPSILON = 오차없이 나타낼수 있는 가장 작은 양의 수, 부동 소수점 오차를 보정\r\n      distance = Math.round((distance + Number.EPSILON) * 100) / 100 / this.DPI * 25.4;\r\n      return distance.toFixed(2) + ' mm';\r\n    },\r\n\r\n    getUnixToTimestamp(time) {\r\n      const date = new Date(time * 1000);\r\n      console.log()\r\n      const year = date.getFullYear();\r\n      const month = \"0\" + (date.getMonth() + 1);\r\n      const day = \"0\" + date.getDate();\r\n      const hour = \"0\" + date.getHours();\r\n      const minute = \"0\" + date.getMinutes();\r\n      const second = \"0\" + date.getSeconds();\r\n      return year + \"-\" + month.substr(-2) + \"-\" + day.substr(-2) + \" \" + hour.substr(-2) + \":\" + minute.substr(-2) + \":\" + second.substr(-2);\r\n      // return new Date().getFullYear() - year;\r\n    },\r\n\r\n    // (My) Web --> One2\r\n    async save() {\r\n      // sharpen, windowing 수정 필요\r\n      await this.getRefImage2Overlayes();\r\n      var data = {\r\n        \"manipulate\": {\"effect\": {\"invert\": this.second.inverse, \"sharpen\": 0}, \"windowing\": {\"wc\": 128, \"ww\": 256}},\r\n        \"overlaies\": this.overlaies\r\n      }\r\n      /*var data = {\r\n        \"manipulate\": {\"effect\": {\"invert\": false, \"sharpen\": 0}, \"windowing\": {\"wc\": 1000, \"ww\": 4000}},\r\n        \"overlaies\": [{\r\n          \"scene_pos\": {\r\n            \"end\": {\"x\": 0.21756374261872313, \"y\": 20.378470558620378},\r\n            \"start\": {\"x\": 0.50764873277702005, \"y\": -12.038527091569339}\r\n          },\r\n          \"style\": {\r\n            \"brush\": {\"color\": \"#00ffffff\"},\r\n            \"pen\": {\"cap\": 32, \"color\": \"#ff0000ff\", \"join\": 128, \"style\": 1, \"width\": 1}\r\n          },\r\n          \"transformation\": {\"rot_deg\": 0},\r\n          \"type\": \"freedraw\"\r\n        }]\r\n      }*/\r\n      // const obj = JSON.parse(json);\r\n      const s = JSON.stringify(data);\r\n      // console.log(s);\r\n      axios({\r\n        // UID: 4629CF54C49549F59AFBB99D9FC82D8F\r\n        // chartID: 20230216001\r\n        // SeriesNum: 1.2.410.200062.2.1.20230216142002130.78.60461.178.202\r\n        url: drf.patient.saveDrwingMarker('1.2.410.200062.2.1.20230216142002130.78.60461.178.202'),\r\n        method: 'post',\r\n        data: s\r\n      })\r\n      // const link = document.createElement('a');\r\n      // link.download = 'param'; // filename\r\n      // link.href = this.image;\r\n      // link.click();\r\n    },\r\n\r\n    /***\r\n     * One2         => Canvas  pen.style\r\n     * length       => line       0\r\n     * multi-length => tapeline\r\n     * angle        => line       0\r\n     * arrow        => line       1\r\n     * ellipse      => circle     1\r\n     * rectangle    => square     1\r\n     * freedraw     => freedraw       1\r\n     * */\r\n    // One2 --> Web\r\n    async importOne2Drawing() {\r\n      for (const m of this.overlaies) {\r\n        // 선 속성 지정\r\n        this.lineColor = '#' + m.style.pen.color.substring(3, 9);\r\n        this.lineWidth = m.style.pen.width - 1;\r\n        // this.lineWidth = m.style.pen.width;\r\n        const stroke = {\r\n          type: '',\r\n          from: {\r\n            x: 0,\r\n            y: 0,\r\n          },\r\n          coordinates: [],\r\n          color: this.lineColor,\r\n          width: this.lineWidth,\r\n          fill: false,\r\n          lineCap: \"round\",\r\n          lineJoin: \"round\",\r\n          valueBox: {\r\n            x: 0,\r\n            y: 0,\r\n          },\r\n        };\r\n        switch (m.type) {\r\n          case \"freedraw\":\r\n            stroke.type = \"freedraw\";\r\n            stroke.from.x = m.scene_pos['control-points'][0].x / 25.4 * this.DPI;\r\n            stroke.from.y = m.scene_pos['control-points'][0].y / 25.4 * this.DPI;\r\n            m.scene_pos['control-points'].forEach(p => {\r\n              stroke.coordinates.push({x: p.x / 25.4 * this.DPI, y: p.y / 25.4 * this.DPI});\r\n            });\r\n            break;\r\n          case \"length\":\r\n            stroke.type = \"length\";\r\n            stroke.from = {x: m.scene_pos.start.x / 25.4 * this.DPI, y: m.scene_pos.start.y / 25.4 * this.DPI}\r\n            stroke.coordinates.push({\r\n              x: m.scene_pos.end.x / 25.4 * this.DPI,\r\n              y: m.scene_pos.end.y / 25.4 * this.DPI\r\n            });\r\n            stroke.coordinates.valueBox = m.scene_pos[\"value-box\"]\r\n            break;\r\n          case \"multi-length\":\r\n            stroke.type = \"tapeline\";\r\n            stroke.from.x = m.scene_pos['control-points'][0].x / 25.4 * this.DPI;\r\n            stroke.from.y = m.scene_pos['control-points'][0].y / 25.4 * this.DPI;\r\n            m.scene_pos['control-points'].forEach(p => {\r\n              stroke.coordinates.push({\r\n                x: p.x / 25.4 * this.DPI,\r\n                y: p.y / 25.4 * this.DPI\r\n              });\r\n            })\r\n            stroke.coordinates.valueBox = m.scene_pos[\"value-box\"]\r\n            break;\r\n        }\r\n        this.drawShape(stroke);\r\n        this.drawMarkArray.push(stroke);\r\n      }\r\n    },\r\n\r\n    /***\r\n     * Canvas     => One2         pen.style\r\n     * line       => length         0\r\n     * tapeline   => multi-length\r\n     * angle      => angle          0\r\n     * arrow      => arrow          1\r\n     * ellipse    => circle         1\r\n     * rectangle  => square         1\r\n     * freedraw       => freedraw       1\r\n     * */\r\n    // Web --> One2\r\n    getRefImage2Overlayes() {\r\n      let data = {\"style\": {}}, scene_pos = {};\r\n      let start = {}, end = {}, value_box = {};\r\n      let coordi, dataType, newArr;\r\n      this.drawMarkArray.forEach(e => {\r\n        data = {\"style\": {}};\r\n        scene_pos = {};\r\n        start = {}, end = {}\r\n        value_box = {};\r\n\r\n        switch (e.type) {\r\n          case \"freedraw\":\r\n            newArr = e.coordinates.map(c => {\r\n              return {x: c.x / this.DPI * 25.4, y: c.y / this.DPI * 25.4};\r\n            })\r\n            scene_pos[\"control-points\"] = newArr;\r\n            data[\"style\"][\"brush\"] = {\"color\": \"#0000ff00\"};\r\n            dataType = \"freedraw\";\r\n            break;\r\n          case \"line\":\r\n            coordi = this.getWeb2One(e.from.x, e.from.y);\r\n            start[\"x\"] = coordi.x;\r\n            start[\"y\"] = coordi.y;\r\n            coordi = this.getWeb2One(e.coordinates[0].x, e.coordinates[0].y);\r\n            end[\"x\"] = coordi.x;\r\n            end[\"y\"] = coordi.y;\r\n            value_box[\"x\"] = e.coordinates[0].valueBox.x;\r\n            value_box[\"y\"] = e.coordinates[0].valueBox.y;\r\n            scene_pos[\"start\"] = start;\r\n            scene_pos[\"end\"] = end;\r\n            scene_pos[\"value-box\"] = value_box;\r\n            data[\"style\"][\"value-box\"] = {\r\n              \"brush\": {\"color\": \"#00ffffff\"},\r\n              \"pen\": {\"cap\": 32, \"color\": \"#00ffffff\", \"join\": 128, \"style\": 0, \"width\": 0},\r\n              \"text\": {\"color\": \"#ffffd700\", \"font-size\": 12}\r\n            };\r\n            dataType = \"length\";\r\n            break;\r\n          case \"tapeline\":\r\n            break;\r\n        }\r\n\r\n        if (e.coordinates.length !== 0) {\r\n          // 1. scene_pos\r\n          data[\"scene_pos\"] = scene_pos;\r\n          // 2. style\r\n          data[\"style\"][\"pen\"] = {\r\n            \"cap\": 32,\r\n            \"color\": '#ff' + e.color.substring(1),\r\n            \"join\": 128,\r\n            \"style\": 1,\r\n            \"width\": e.width + 1\r\n          };\r\n          // 3. transformation\r\n          data[\"transformation\"] = {\"rot_deg\": 0};\r\n          // 4. type\r\n          data[\"type\"] = dataType;\r\n          this.overlaies.push(data);\r\n        }\r\n      })\r\n    },\r\n\r\n    ...mapActions([\r\n      Constant.GET_PATIENTRECORDLIST,\r\n      Constant.GET_PATIENTSERIESLIST,\r\n    ]),\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n#canvas {\r\n  border: 1px solid black;\r\n}\r\n\r\n.baseHeaderView {\r\n  background-color: black;\r\n  width: 100%;\r\n  height: calc(100% - 80px);\r\n  display: flex;\r\n}\r\n\r\n.baseUtilityView {\r\n  /* debug용 */\r\n  /*background-color: orange;*/\r\n  background-color: black;\r\n  height: 100%;\r\n  width: 100%;\r\n  position: relative;\r\n  /*justify-content: flex-start;*/\r\n  /*overflow: auto;*/\r\n\r\n  justify-content: center;\r\n  overflow: hidden;\r\n}\r\n\r\n.information {\r\n  position: absolute;\r\n  left: 10px;\r\n  top: 10px;\r\n\r\n  text-shadow: 1px 0 1px #000;\r\n  font-family: MalgunGothic;\r\n  font-size: 18px;\r\n  font-weight: bold;\r\n  font-stretch: normal;\r\n  font-style: normal;\r\n  line-height: 1.22;\r\n  letter-spacing: -0.64px;\r\n  color: #fff;\r\n}\r\n\r\n.isToggle {\r\n  border: solid 2px blue;\r\n}\r\n</style>"]},"metadata":{},"sourceType":"module","externalDependencies":[]}